# ğŸ” DEEP DIVE: IDOR Vulnerability Analysis

## What is IDOR?

**IDOR = Insecure Direct Object Reference**

This is when your application allows users to access resources (like reservations, profiles, documents) by directly using an identifier (like UUID) **without properly checking if the user has permission** to access that resource.

---

## ğŸ¯ THE VULNERABILITY EXPLAINED (Simple Terms)

### How It Should Work:
```
User A creates reservation â†’ Gets ID: abc-123
User A views /reservation/abc-123 â†’ âœ… Can see it (owns it)
User B tries /reservation/abc-123 â†’ âŒ BLOCKED (not owner)
```

### How It Works Now (VULNERABLE):
```
User A creates reservation â†’ Gets ID: abc-123
User A views /reservation/abc-123 â†’ âœ… Can see it (owns it)
User B tries /reservation/abc-123 â†’ âš ï¸ CAN SEE IT! (security bug)
```

**The Problem:** Any logged-in user can view ANY reservation if they know or guess the UUID.

---

## ğŸ”¬ ACTUAL CODE ANALYSIS

### Current Implementation (VULNERABLE)

**File: `src/lib/api/reservations.ts:346-360`**
```typescript
export const getReservationById = async (reservationId: string): Promise<Reservation | null> => {
  // Step 1: Fetch reservation from database
  const { data: basicData, error: basicError } = await supabase
    .from('reservations')
    .select('*')
    .eq('id', reservationId)  // âš ï¸ No check if user owns this!
    .maybeSingle();

  // Returns the reservation WITHOUT verifying ownership
  return basicData;
}
```

**What's Missing:**
- âŒ No check: `customer_id = current_user.id`
- âŒ No check: `partner_id = current_user.partner_id`
- âŒ No admin-only exception

### Database RLS Policies (PROTECTION LAYER)

**File: `supabase/migrations/20251123_fix_customer_reservation_rls.sql`**
```sql
-- âœ… GOOD: This policy EXISTS and IS CORRECT
CREATE POLICY "Customers can read their own reservations"
  ON public.reservations
  FOR SELECT
  USING (
    customer_id = auth.uid()  -- âœ… Checks ownership
  );

CREATE POLICY "Partners can view reservations for their offers"
  ON public.reservations
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.partners
      WHERE partners.user_id = auth.uid()
      AND partners.id = reservations.partner_id
    )
  );
```

---

## âœ… ACTUAL STATUS: **PROTECTED** (But Needs Verification)

### Good News:
Your database **DOES HAVE** Row-Level Security (RLS) policies that check ownership. This means:

```
User A (id: user-aaa) â†’ SELECT * FROM reservations WHERE id = 'res-123'
Database checks: res-123.customer_id == 'user-aaa'? 
  âœ… YES â†’ Return data
  âŒ NO  â†’ Return nothing (blocked by RLS)
```

### Why I Flagged It as Vulnerable:

1. **Application code doesn't enforce it** - Relies 100% on database
2. **If RLS is accidentally disabled** - Instant data breach
3. **No admin exception** - Admins might be blocked too
4. **No audit logging** - Can't detect access attempts

---

## ğŸ§ª TESTING THE VULNERABILITY

### Test Script (Run this to verify):
```typescript
// Test 1: Try to access someone else's reservation
const testIDOR = async () => {
  // Login as User A
  const userA = await signIn('usera@test.com', 'password');
  
  // User A creates a reservation
  const reservation = await createReservation(offerId, userA.id, 1);
  console.log('Created reservation:', reservation.id);
  
  // Logout User A, login as User B
  await signOut();
  const userB = await signIn('userb@test.com', 'password');
  
  // User B tries to access User A's reservation
  try {
    const stolen = await getReservationById(reservation.id);
    
    if (stolen) {
      console.error('ğŸ”´ IDOR VULNERABILITY CONFIRMED!');
      console.error('User B can see User A\'s reservation:', stolen);
      return 'VULNERABLE';
    } else {
      console.log('âœ… PROTECTED: RLS blocked access');
      return 'SAFE';
    }
  } catch (error) {
    console.log('âœ… PROTECTED: Access denied');
    return 'SAFE';
  }
};
```

### What We Expect:
- **If RLS is working:** `stolen` will be `null` âœ…
- **If vulnerable:** `stolen` will contain User A's data ğŸ”´

---

## ğŸ¯ REAL-WORLD ATTACK SCENARIOS

### Scenario 1: UUID Enumeration Attack
```javascript
// Attacker script (automated):
const knownUUIDs = [
  '123e4567-e89b-12d3-a456-426614174000',
  '123e4567-e89b-12d3-a456-426614174001',
  '123e4567-e89b-12d3-a456-426614174002',
  // ... generate 10,000 variations
];

for (const uuid of knownUUIDs) {
  const reservation = await getReservationById(uuid);
  if (reservation) {
    console.log('FOUND:', {
      customer: reservation.customer_id,
      partner: reservation.partner_id,
      qr_code: reservation.qr_code,
      pickup_location: reservation.partner?.address
    });
  }
}
```

**Data Exposed:**
- âŒ Customer IDs (track user behavior)
- âŒ QR codes (potentially forge pickups)
- âŒ Partner locations (competitor intelligence)
- âŒ Order patterns (when users eat, where)

### Scenario 2: Partner Spying on Competitors
```javascript
// Competitor partner views rival's reservations:
const spyOnCompetitor = async (competitorPartnerId) => {
  // Get all offers from competitor
  const { data: offers } = await supabase
    .from('offers')
    .select('id')
    .eq('partner_id', competitorPartnerId);
  
  // Try to access reservations for those offers
  for (const offer of offers) {
    const { data: reservations } = await supabase
      .from('reservations')
      .select('*')
      .eq('offer_id', offer.id);
    
    console.log('Competitor stats:', {
      totalReservations: reservations.length,
      revenue: reservations.length * avgPrice
    });
  }
};
```

**Impact:**
- ğŸ“Š Steal competitor sales data
- ğŸ’° Calculate competitor revenue
- ğŸ“ˆ Identify best-selling items

---

## ğŸ›¡ï¸ CURRENT PROTECTION STATUS

### âœ… What IS Protected:
```sql
-- RLS policies ARE enabled (confirmed in migrations):
ALTER TABLE public.reservations ENABLE ROW LEVEL SECURITY;

-- Policy 1: Customers can only see their own
CREATE POLICY "Customers can read their own reservations"
  ON reservations FOR SELECT
  USING (customer_id = auth.uid());

-- Policy 2: Partners can only see their own
CREATE POLICY "Partners can view reservations for their offers"
  ON reservations FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM partners
      WHERE partners.user_id = auth.uid()
      AND partners.id = reservations.partner_id
    )
  );
```

### âš ï¸ What's MISSING:
```sql
-- Missing: Admin access policy
CREATE POLICY "Admins can view all reservations"
  ON reservations FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE id = auth.uid() AND role = 'ADMIN'
    )
  );
```

### âš ï¸ Application-Level Gaps:
```typescript
// Current code (no explicit check):
export const getReservationById = async (reservationId: string) => {
  const { data } = await supabase
    .from('reservations')
    .select('*')
    .eq('id', reservationId)
    .maybeSingle();
  
  return data; // âš ï¸ Trusts RLS 100%
}

// SHOULD BE (defense in depth):
export const getReservationById = async (reservationId: string, userId: string) => {
  const { data } = await supabase
    .from('reservations')
    .select('*')
    .eq('id', reservationId)
    .maybeSingle();
  
  // âœ… Double-check ownership at application level
  if (data && data.customer_id !== userId) {
    // Check if user is partner
    const { data: partner } = await supabase
      .from('partners')
      .select('id')
      .eq('user_id', userId)
      .eq('id', data.partner_id)
      .single();
    
    if (!partner) {
      // Check if user is admin
      const { data: user } = await supabase
        .from('users')
        .select('role')
        .eq('id', userId)
        .single();
      
      if (user?.role !== 'ADMIN') {
        throw new Error('Access denied');
      }
    }
  }
  
  return data;
}
```

---

## ğŸ”§ RECOMMENDED FIXES

### Priority 1: Add Admin RLS Policy (5 minutes)
```sql
-- File: ADD_ADMIN_RESERVATION_ACCESS.sql
CREATE POLICY "Admins can view all reservations"
  ON public.reservations
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM public.users
      WHERE id = auth.uid() AND role = 'ADMIN'
    )
  );
```

### Priority 2: Add Application-Level Validation (30 minutes)
```typescript
// File: src/lib/api/reservations.ts

export const getReservationById = async (
  reservationId: string,
  requestingUserId?: string
): Promise<Reservation | null> => {
  const { data, error } = await supabase
    .from('reservations')
    .select('*')
    .eq('id', reservationId)
    .maybeSingle();

  if (error) throw error;
  if (!data) return null;

  // âœ… Application-level ownership verification (defense in depth)
  if (requestingUserId && data.customer_id !== requestingUserId) {
    // Check if requesting user is the partner
    const { data: partner } = await supabase
      .from('partners')
      .select('id')
      .eq('user_id', requestingUserId)
      .eq('id', data.partner_id)
      .single();

    if (!partner) {
      // Check if requesting user is admin
      const { data: user } = await supabase
        .from('users')
        .select('role')
        .eq('id', requestingUserId)
        .single();

      if (user?.role !== 'ADMIN') {
        logger.warn(`Unauthorized access attempt to reservation ${reservationId} by user ${requestingUserId}`);
        return null; // Silently fail (don't reveal existence)
      }
    }
  }

  return data;
};
```

### Priority 3: Add Audit Logging (1 hour)
```typescript
// Log all reservation access attempts
const logReservationAccess = async (
  reservationId: string,
  userId: string,
  action: 'view' | 'update' | 'delete',
  allowed: boolean
) => {
  await supabase.from('audit_log').insert({
    user_id: userId,
    action,
    resource_type: 'reservation',
    resource_id: reservationId,
    allowed,
    ip_address: req.headers.get('cf-connecting-ip'),
    user_agent: req.headers.get('user-agent'),
    timestamp: new Date()
  });
};
```

### Priority 4: Add Rate Limiting for Access Attempts (1 hour)
```typescript
// Detect UUID enumeration attacks
const rateLimitReservationAccess = async (userId: string) => {
  const recentAttempts = await supabase
    .from('audit_log')
    .select('id')
    .eq('user_id', userId)
    .eq('resource_type', 'reservation')
    .eq('allowed', false)
    .gte('timestamp', new Date(Date.now() - 3600000)); // Last hour

  if (recentAttempts.data && recentAttempts.data.length > 20) {
    // Flag user as suspicious
    await supabase.from('suspicious_activity').insert({
      user_id: userId,
      activity_type: 'IDOR_ENUMERATION',
      severity: 'HIGH',
      details: `${recentAttempts.data.length} failed reservation access attempts in 1 hour`
    });
    
    throw new Error('Too many access attempts. Account flagged for review.');
  }
};
```

---

## ğŸ“Š SEVERITY REASSESSMENT

### Original Assessment: 8.8/10 (CRITICAL)
**Reasoning:** Assumed no RLS protection

### Updated Assessment: 5.5/10 (MEDIUM)
**Reasoning:** 
- âœ… RLS policies ARE in place and working
- âœ… Database-level protection is active
- âš ï¸ No application-level validation (single point of failure)
- âš ï¸ No admin access policy (admin panel might break)
- âš ï¸ No audit logging (can't detect attacks)
- âš ï¸ No enumeration protection

### Risk Level: ğŸŸ¡ MEDIUM (Not Critical, but should fix)

**Why not critical:**
- Database RLS prevents actual data leaks
- Requires authenticated user (not public)
- UUIDs are hard to guess (not sequential)

**Why still a concern:**
- 100% reliance on RLS (no defense in depth)
- If RLS accidentally disabled â†’ instant breach
- No visibility into access attempts
- Admins might not be able to view reservations

---

## âœ… ACTION PLAN

### Immediate (This Week):
1. âœ… Verify RLS is enabled in production (run CHECK_CURRENT_RESERVATION_RLS.sql)
2. ğŸ”§ Add admin RLS policy (5 min)
3. ğŸ”§ Add application-level validation (30 min)

### Short-term (This Month):
4. ğŸ“Š Add audit logging for reservation access (1 hour)
5. ğŸš¨ Add rate limiting for access attempts (1 hour)
6. ğŸ§ª Create automated tests for IDOR protection (2 hours)

### Long-term (Next Quarter):
7. ğŸ“ˆ Monitor audit logs for suspicious patterns
8. ğŸ” Implement anomaly detection for UUID enumeration
9. ğŸ›¡ï¸ Add honeypot reservations to detect attackers

**Total Fix Time:** 2-3 hours (immediate) + 4-5 hours (short-term)

---

## ğŸ“ CONCLUSION

**Your app is PROTECTED at the database level** âœ…  
**But relies on a single defense layer** âš ï¸  
**Recommendation: Add defense-in-depth** ğŸ›¡ï¸

The IDOR vulnerability I flagged is **PARTIALLY MITIGATED** by your RLS policies, but I strongly recommend adding:
1. Application-level checks (defense in depth)
2. Admin access policy (operational requirement)
3. Audit logging (security monitoring)
4. Rate limiting (attack detection)

**Revised Priority:** ğŸŸ¡ MEDIUM (Fix within 1-2 weeks, not blocking launch)
