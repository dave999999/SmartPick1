-- =========================================================
-- FIX COOLDOWN LIFT FARMING EXPLOIT
-- =========================================================
-- Issue: Users can lift cooldown multiple times per day
-- Attack: Cancel 3x ‚Üí FREE lift ‚Üí Cancel 3x ‚Üí FREE lift (repeat)
-- Fix: Add unique constraint (1 lift per day per user)
-- =========================================================

-- STEP 1: Check current table structure
-- Note: \d command only works in psql, use this query instead:
SELECT 
  column_name, 
  data_type, 
  is_nullable
FROM information_schema.columns
WHERE table_name = 'user_cooldown_lifts'
ORDER BY ordinal_position;

-- STEP 2: Check if any user has lifted multiple times today
DO $$ BEGIN RAISE NOTICE '=== CHECKING FOR EXISTING ABUSE (multiple lifts per day) ==='; END $$;
WITH georgia_lifts AS (
  SELECT 
    user_id,
    lift_type,
    (lifted_at AT TIME ZONE 'Asia/Tbilisi')::DATE AS lift_date,
    COUNT(*) AS lifts_today
  FROM user_cooldown_lifts
  WHERE (lifted_at AT TIME ZONE 'Asia/Tbilisi')::DATE = (NOW() AT TIME ZONE 'Asia/Tbilisi')::DATE
  GROUP BY user_id, lift_type, (lifted_at AT TIME ZONE 'Asia/Tbilisi')::DATE
  HAVING COUNT(*) > 1
)
SELECT 
  u.email,
  gl.lift_type,
  gl.lift_date,
  gl.lifts_today,
  CASE 
    WHEN gl.lifts_today > 1 THEN '‚ö†Ô∏è EXPLOIT DETECTED'
    ELSE 'OK'
  END AS status
FROM georgia_lifts gl
JOIN users u ON u.id = gl.user_id
ORDER BY gl.lifts_today DESC;

-- STEP 3: Check if unique index already exists
DO $$ BEGIN RAISE NOTICE '=== CHECKING FOR EXISTING UNIQUE INDEX ==='; END $$;
SELECT 
  indexname,
  indexdef
FROM pg_indexes
WHERE tablename = 'user_cooldown_lifts'
  AND indexname LIKE '%one_lift%';

-- STEP 4A: Clean up existing duplicates (keep only the FIRST lift per user per day)
DO $$ BEGIN RAISE NOTICE '=== CLEANING UP DUPLICATE LIFTS ==='; END $$;
WITH duplicates AS (
  SELECT 
    id,
    ROW_NUMBER() OVER (
      PARTITION BY user_id, (lifted_at AT TIME ZONE 'Asia/Tbilisi')::DATE 
      ORDER BY lifted_at ASC
    ) AS row_num
  FROM user_cooldown_lifts
)
DELETE FROM user_cooldown_lifts
WHERE id IN (
  SELECT id FROM duplicates WHERE row_num > 1
);

-- Show how many duplicates were removed
DO $$ 
DECLARE
  v_deleted_count INTEGER;
BEGIN
  GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
  RAISE NOTICE 'Deleted % duplicate lift records', v_deleted_count;
END $$;

-- STEP 4B: Add unique index (1 lift per day per user)
DO $$ BEGIN RAISE NOTICE '=== ADDING UNIQUE CONSTRAINT ==='; END $$;
CREATE UNIQUE INDEX IF NOT EXISTS idx_one_lift_per_user_per_day 
ON user_cooldown_lifts(
  user_id, 
  ((lifted_at AT TIME ZONE 'Asia/Tbilisi')::DATE)
);

-- STEP 5: Update reset_user_cooldown function to check constraint
DO $$ BEGIN RAISE NOTICE '=== UPDATING reset_user_cooldown FUNCTION ==='; END $$;
CREATE OR REPLACE FUNCTION reset_user_cooldown(
  p_user_id UUID,
  p_lift_type TEXT DEFAULT 'free'
)
RETURNS TABLE(
  success BOOLEAN,
  message TEXT,
  cooldown_lifted BOOLEAN,
  points_spent INTEGER
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = 'public'
AS $$
DECLARE
  v_georgia_date DATE;
  v_cancellation_count INTEGER;
  v_in_cooldown BOOLEAN;
  v_required_points INTEGER := 0;
  v_user_balance INTEGER;
BEGIN
  -- Get current date in Georgia timezone
  v_georgia_date := (NOW() AT TIME ZONE 'Asia/Tbilisi')::DATE;
  
  -- üîí CRITICAL FIX: Check if already lifted today
  IF EXISTS (
    SELECT 1 FROM user_cooldown_lifts
    WHERE user_id = p_user_id
      AND (lifted_at AT TIME ZONE 'Asia/Tbilisi')::DATE = v_georgia_date
  ) THEN
    RETURN QUERY SELECT 
      FALSE,
      'You have already lifted cooldown today. Try again after midnight (Georgia time).'::TEXT,
      FALSE,
      0;
    RETURN;
  END IF;
  
  -- Get current cancellation count (today only)
  SELECT COUNT(*) INTO v_cancellation_count
  FROM user_cancellation_tracking
  WHERE user_id = p_user_id
    AND (cancelled_at AT TIME ZONE 'Asia/Tbilisi')::DATE = v_georgia_date;
  
  -- Check if user is in cooldown
  SELECT in_cooldown INTO v_in_cooldown
  FROM users
  WHERE id = p_user_id;
  
  IF NOT v_in_cooldown THEN
    RETURN QUERY SELECT 
      FALSE,
      'You are not in cooldown'::TEXT,
      FALSE,
      0;
    RETURN;
  END IF;
  
  -- Determine required points based on cancellation count
  CASE 
    WHEN v_cancellation_count = 3 THEN
      v_required_points := 0; -- FREE lift
    WHEN v_cancellation_count = 4 THEN
      v_required_points := 100;
    WHEN v_cancellation_count >= 5 THEN
      RETURN QUERY SELECT 
        FALSE,
        'You have reached the daily cancellation limit. Cooldown will reset at midnight (Georgia time).'::TEXT,
        FALSE,
        0;
      RETURN;
    ELSE
      RETURN QUERY SELECT 
        FALSE,
        'You need at least 3 cancellations to lift cooldown'::TEXT,
        FALSE,
        0;
      RETURN;
  END CASE;
  
  -- If paid lift, check balance
  IF v_required_points > 0 THEN
    SELECT balance INTO v_user_balance
    FROM user_points
    WHERE user_id = p_user_id;
    
    IF v_user_balance < v_required_points THEN
      RETURN QUERY SELECT 
        FALSE,
        format('Insufficient points. Required: %s, Available: %s', v_required_points, v_user_balance),
        FALSE,
        0;
      RETURN;
    END IF;
    
    -- Deduct points
    UPDATE user_points
    SET balance = balance - v_required_points,
        updated_at = NOW()
    WHERE user_id = p_user_id;
    
    -- Log transaction
    INSERT INTO point_transactions (
      user_id,
      type,
      amount,
      balance_before,
      balance_after,
      description,
      metadata
    ) VALUES (
      p_user_id,
      'deduct',
      v_required_points,
      v_user_balance,
      v_user_balance - v_required_points,
      'Lifted cancellation cooldown',
      json_build_object(
        'cancellation_count', v_cancellation_count,
        'lift_type', 'paid'
      )
    );
  END IF;
  
  -- Record cooldown lift
  INSERT INTO user_cooldown_lifts (
    user_id,
    lift_type,
    points_spent,
    cancellation_count_at_lift,
    lifted_at
  ) VALUES (
    p_user_id,
    CASE WHEN v_required_points = 0 THEN 'free' ELSE 'paid' END,
    v_required_points,
    v_cancellation_count,
    NOW()
  );
  
  -- Reset cooldown status
  UPDATE users
  SET in_cooldown = false,
      updated_at = NOW()
  WHERE id = p_user_id;
  
  -- Return success
  RETURN QUERY SELECT 
    TRUE,
    'Cooldown lifted successfully!'::TEXT,
    TRUE,
    v_required_points;

EXCEPTION
  WHEN unique_violation THEN
    RETURN QUERY SELECT 
      FALSE,
      'You have already lifted cooldown today'::TEXT,
      FALSE,
      0;
  WHEN OTHERS THEN
    RETURN QUERY SELECT 
      FALSE,
      'Error: ' || SQLERRM,
      FALSE,
      0;
END;
$$;

-- STEP 6: Verify unique constraint exists
DO $$ BEGIN RAISE NOTICE '=== VERIFYING UNIQUE CONSTRAINT ==='; END $$;
SELECT 
  indexname,
  indexdef
FROM pg_indexes
WHERE tablename = 'user_cooldown_lifts'
  AND indexname = 'idx_one_lift_per_user_per_day';

-- STEP 7: Test the constraint (should fail on duplicate)
DO $$ BEGIN RAISE NOTICE '=== TESTING CONSTRAINT (this will fail if user already lifted today) ==='; END $$;
DO $$
DECLARE
  v_test_user_id UUID;
  v_test_passed BOOLEAN := FALSE;
BEGIN
  -- Get a real user ID
  SELECT id INTO v_test_user_id
  FROM users
  LIMIT 1;
  
  IF v_test_user_id IS NULL THEN
    RAISE NOTICE '‚ö†Ô∏è  No users found to test with';
    RETURN;
  END IF;
  
  -- Try to insert duplicate lift for today
  BEGIN
    INSERT INTO user_cooldown_lifts (user_id, lift_type, points_spent, cancellation_count_at_lift)
    VALUES (v_test_user_id, 'free', 0, 3);
    
    INSERT INTO user_cooldown_lifts (user_id, lift_type, points_spent, cancellation_count_at_lift)
    VALUES (v_test_user_id, 'free', 0, 3);
    
    RAISE NOTICE '‚ùå TEST FAILED: Should have prevented duplicate lift';
  EXCEPTION
    WHEN unique_violation THEN
      RAISE NOTICE '‚úÖ TEST PASSED: Constraint prevented duplicate lift';
      v_test_passed := TRUE;
  END;
  
  -- Clean up test data if test passed
  IF v_test_passed THEN
    DELETE FROM user_cooldown_lifts 
    WHERE user_id = v_test_user_id 
      AND (lifted_at AT TIME ZONE 'Asia/Tbilisi')::DATE = (NOW() AT TIME ZONE 'Asia/Tbilisi')::DATE
      AND points_spent = 0
      AND cancellation_count_at_lift = 3;
  END IF;
END;
$$;

-- STEP 8: Show summary
DO $$ BEGIN RAISE NOTICE '=== FIX SUMMARY ==='; END $$;
SELECT 
  '‚úÖ Added unique index: idx_one_lift_per_user_per_day' AS fix_1
UNION ALL
SELECT 
  '‚úÖ Updated reset_user_cooldown function to check constraint' AS fix_2
UNION ALL
SELECT 
  '‚úÖ Users can now only lift cooldown ONCE per day' AS fix_3
UNION ALL
SELECT 
  '‚úÖ Exploit prevented: No more cooldown lift farming' AS fix_4;

-- Current Statistics:
DO $$ BEGIN RAISE NOTICE 'üìä Current Statistics:'; END $$;
SELECT 
  COUNT(*) AS total_lifts_today,
  COUNT(DISTINCT user_id) AS unique_users,
  CASE 
    WHEN COUNT(*) > COUNT(DISTINCT user_id) 
    THEN '‚ö†Ô∏è Multiple lifts detected (data before fix)'
    ELSE '‚úÖ All users have max 1 lift per day'
  END AS status
FROM user_cooldown_lifts
WHERE (lifted_at AT TIME ZONE 'Asia/Tbilisi')::DATE = (NOW() AT TIME ZONE 'Asia/Tbilisi')::DATE;

-- ‚úÖ COOLDOWN LIFT EXPLOIT FIXED!
-- What changed:
-- - Users can only lift cooldown ONCE per day
-- - Unique index prevents duplicate lifts
-- - Function returns clear error: "You have already lifted cooldown today"
-- - Exploit: Cancel 3x ‚Üí Lift ‚Üí Cancel 3x ‚Üí Lift (BLOCKED)
-- Next: Test by trying to lift cooldown twice in same day
